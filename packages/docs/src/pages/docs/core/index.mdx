---
icon: core
title: Booleon Core
description: Booleon core is a collection of functions with a goal to manipulate and compile CSS, based on boolean props.
---

# Introduction

`Booleon` core is a collection of functions with a goal to `manipulate` and `compile` CSS, based on `boolean props`.

# Instalation

```shell
npm i @booleon/core
```

```shell
yarn add @booleon/core
```

# Under the hood

## browserPrefixer

For this feature it's been used [style-vendorizer](https://github.com/kripod/style-vendorizer) by
[kripod](https://github.com/kripod), since it's really lightweight,
and on top of it allowing separated or joined attribute and value.

```tsx
export function browserPrefixer(...str: string[]) {
  if (str.map(Boolean).includes(false)) return '';
  if (str.length < 2) {
    const cssPropRegex = /(?<attr>.*):(?<value>.*);/;
    const { attr, value } = cssPropRegex?.exec(str[0])?.groups || {};
    return attr && value ? styleDeclaration(attr, value) : str[0];
  }
  return styleDeclaration(...str);
}
...
function browserPrefixer('position:sticky;');
// 'position:-webkit-sticky;position:sticky;'
```

## cleanTransformFilter

The motivation for this feature was, allowing the [transform]() and
[filter]() modules to have, not only css values, but also its attributes.

PS: BUT for this to work the compiled filters must be near one another.

```tsx
export function cleanTransformFilter(str: string) {
  return [/transform:.*(;transform:)/g, /filter:.*(;filter:)/g].reduce(
    (acc, rgx) =>
      acc.replace(rgx, (match, group) =>
        match.replace(new RegExp(group, 'g'), ''),
      ),
    str,
  );
}
...
cleanTransformFilter('filter:invert(100%);filter:blur(1rem);');
// 'filter:invert(100%);filter:blur(1rem);'
cleanTransformFilter('transform:transform:translateY(-100);transform:translateX(100);');
// transform:translateY(-100)translateX(100);
```

## composeProps

The goal of this feature is to get an key value object and prepare it to be used by the
[styleCompiler](#styleCompiler).

```tsx
export function composeProps(props: Props) {
  const recusiveReducer = (
    acc = {},
    splitKey: string[],
    value: Props,
  ): Props => {
    const [key, ...rest] = splitKey;
    if (rest.length) {
      return {
        ...acc,
        [key]: { ...acc[key], ...recusiveReducer(acc[key], rest, value) },
      };
    }
    return { ...acc, css: { ...acc['css'], [key]: value } };
  };

  return Object.keys(props).reduce((acc, key) => {
    if (!props[key]) return acc;
    return { ...acc, ...recusiveReducer(acc, key.split('__'), props[key]) };
  }, {});
}
...
composeProps({ prefix__style: true, style: true, falsy_style: false });
/*
  {
    prefix: {
      css: {
        style: true,
      },
    },
    css: {
      style: true,
    },
  }
*/
```

## cssCompiler

## defaultPrefixes

## prefixerHandlers

## stringHash

## styleAppender

## styleCompiler

## uniqueClass
